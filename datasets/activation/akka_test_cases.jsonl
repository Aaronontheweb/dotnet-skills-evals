{"id": "act-001", "user_prompt": "I have a notification system where actors publish events when users do things, and other actors subscribe to those events. It works great on a single node but now that we're running a 3-node cluster, subscribers on other nodes never see the events. What am I missing here?\n\n```csharp\npublic class OrderCompletedActor : ReceiveActor\n{\n    public OrderCompletedActor()\n    {\n        Receive<OrderCompleted>(msg =>\n        {\n            // Publish to all subscribers\n            Context.System.EventStream.Publish(msg);\n        });\n    }\n}\n\npublic class AnalyticsActor : ReceiveActor\n{\n    public AnalyticsActor()\n    {\n        Context.System.EventStream.Subscribe<OrderCompleted>(Self);\n        Receive<OrderCompleted>(msg =>\n        {\n            _metrics.TrackOrderCompletion(msg.OrderId);\n        });\n    }\n}\n```\n\nThe AnalyticsActor is running on node B but OrderCompletedActor is on node A. Events never arrive.", "expected_skills": ["akka-net-best-practices"], "acceptable_skills": [], "should_activate": true, "category": "best-practices-pubsub"}
{"id": "act-002", "user_prompt": "This actor calls our payment gateway API and it keeps getting restarted by its parent every time the gateway returns a 503. The whole actor state gets wiped and the user has to start the checkout flow over. Super frustrating. I just want it to log the error and retry, not blow up.\n\n```csharp\npublic class PaymentProcessorActor : ReceiveActor\n{\n    private PaymentState _state;\n\n    public PaymentProcessorActor(IPaymentGateway gateway)\n    {\n        _state = new PaymentState();\n\n        ReceiveAsync<ProcessPayment>(async msg =>\n        {\n            _state.CurrentOrderId = msg.OrderId;\n            var result = await gateway.ChargeAsync(msg.Amount, msg.Token);\n            Sender.Tell(new PaymentResult(result.TransactionId));\n        });\n    }\n}\n```\n\nThe `ChargeAsync` throws `HttpRequestException` on 503 and then supervision kills the actor. How should I handle this?", "expected_skills": ["akka-net-best-practices"], "acceptable_skills": [], "should_activate": true, "category": "best-practices-supervision"}
{"id": "act-003", "user_prompt": "I'm trying to set up a supervision strategy for my actor so that when it gets a `NullReferenceException` it stops, and for everything else it restarts. But it never works -- the actor just restarts on NullRef too. I added logging and the `SupervisorStrategy` method IS being called but the behavior doesn't change.\n\n```csharp\npublic class InventoryActor : ReceiveActor\n{\n    protected override SupervisorStrategy SupervisorStrategy()\n    {\n        return new OneForOneStrategy(ex =>\n        {\n            if (ex is NullReferenceException)\n            {\n                _logger.LogError(ex, \"Stopping due to null ref\");\n                return Directive.Stop;\n            }\n            return Directive.Restart;\n        });\n    }\n\n    public InventoryActor()\n    {\n        Receive<CheckStock>(msg =>\n        {\n            // processing logic that sometimes throws\n            var qty = _repo.GetQuantity(msg.Sku);\n            Sender.Tell(new StockResult(qty));\n        });\n    }\n}\n```\n\nWhat am I doing wrong with this strategy? The actor itself is the one crashing, not its children.", "expected_skills": ["akka-net-best-practices"], "acceptable_skills": [], "should_activate": true, "category": "best-practices-supervision"}
{"id": "act-004", "user_prompt": "I need my actor to use `IHttpClientFactory` from DI. Right now I'm capturing it in a closure and passing it into Props but I've read that closures in Props are bad. What's the right way to wire this up?\n\n```csharp\npublic class Startup\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddHttpClient();\n    }\n\n    public void ConfigureActors(ActorSystem system, IServiceProvider sp)\n    {\n        var factory = sp.GetRequiredService<IHttpClientFactory>();\n        var props = Props.Create(() => new ApiPollerActor(factory));\n        system.ActorOf(props, \"api-poller\");\n    }\n}\n\npublic class ApiPollerActor : ReceiveActor\n{\n    public ApiPollerActor(IHttpClientFactory httpFactory)\n    {\n        ReceiveAsync<PollApi>(async msg =>\n        {\n            var client = httpFactory.CreateClient();\n            var response = await client.GetAsync(msg.Url);\n            // ...\n        });\n    }\n}\n```\n\nThe closure captures `factory` which feels wrong. Is there a proper DI pattern for Akka.NET actors?", "expected_skills": ["akka-net-best-practices"], "acceptable_skills": ["akka-hosting-actor-patterns"], "should_activate": true, "category": "best-practices-props"}
{"id": "act-005", "user_prompt": "We're modernizing a big Akka.NET app and I'm tasked with getting rid of the HOCON config files. The app works fine but we want everything in C# so new devs don't have to learn HOCON. Here's a sample of what we have now -- what's the modern equivalent?\n\n```hocon\nakka {\n    actor {\n        provider = cluster\n    }\n    remote {\n        dot-netty.tcp {\n            hostname = \"0.0.0.0\"\n            public-hostname = \"localhost\"\n            port = 8081\n        }\n    }\n    cluster {\n        seed-nodes = [\"akka.tcp://MySystem@localhost:8081\"]\n        roles = [\"worker\"]\n    }\n    persistence {\n        journal.plugin = \"akka.persistence.journal.sql-server\"\n        journal.sql-server {\n            connection-string = \"Server=localhost;Database=AkkaDb;...\"\n        }\n    }\n}\n```\n\nI know there's an `Akka.Hosting` package but I don't know where to start with converting all this.", "expected_skills": ["akka-net-best-practices"], "acceptable_skills": ["akka-hosting-actor-patterns"], "should_activate": true, "category": "best-practices-hosting"}
{"id": "act-006", "user_prompt": "I've got a persistent actor that tracks shopping cart state via event sourcing. I need to write tests that verify the events are persisted correctly and that the actor recovers its state after a restart. Never used the test infrastructure for persistent actors before -- my current test just creates the actor and sends messages but I have no idea how to simulate a restart or verify the journal.\n\n```csharp\npublic class ShoppingCartActor : ReceivePersistenceActor\n{\n    public override string PersistenceId { get; }\n    private CartState _state = new();\n\n    public ShoppingCartActor(string cartId)\n    {\n        PersistenceId = $\"cart-{cartId}\";\n\n        Command<AddItem>(cmd =>\n        {\n            var evt = new ItemAdded(cmd.Sku, cmd.Qty);\n            Persist(evt, e =>\n            {\n                _state = _state.Apply(e);\n                Sender.Tell(new CartUpdated(_state));\n            });\n        });\n\n        Recover<ItemAdded>(evt => _state = _state.Apply(evt));\n    }\n}\n```\n\nHow do I set up a proper test harness for this? I'm using xUnit.", "expected_skills": ["akka-net-testing-patterns"], "acceptable_skills": [], "should_activate": true, "category": "testing-persistence"}
{"id": "act-007", "user_prompt": "I have a coordinator actor that fans out work to child actors, then aggregates the results. I need to test that the coordinator sends the right messages to each child AND that it combines the responses correctly. Right now my test only checks the final output but I want to verify the intermediate message flow too.\n\n```csharp\npublic class BatchProcessorActor : ReceiveActor\n{\n    public BatchProcessorActor()\n    {\n        Receive<ProcessBatch>(msg =>\n        {\n            foreach (var item in msg.Items)\n            {\n                var child = Context.ActorOf(\n                    Props.Create(() => new ItemProcessorActor()),\n                    $\"item-{item.Id}\");\n                child.Tell(new ProcessItem(item));\n            }\n        });\n\n        Receive<ItemProcessed>(msg =>\n        {\n            _results.Add(msg);\n            if (_results.Count == _expectedCount)\n                _requester.Tell(new BatchComplete(_results));\n        });\n    }\n}\n```\n\nI want to intercept the messages going to children. Is there a way to inject test probes as child actors or something?", "expected_skills": ["akka-net-testing-patterns"], "acceptable_skills": [], "should_activate": true, "category": "testing-probes"}
{"id": "act-008", "user_prompt": "I'm losing my mind with this flaky test. It passes like 7 out of 10 times. The actor processes messages asynchronously and sometimes the `ExpectMsg` times out even though the message IS being sent (I added logging). I think it's a timing issue but bumping the timeout to 30 seconds didn't fix it either.\n\n```csharp\n[Fact]\npublic void Should_process_and_respond()\n{\n    var actor = Sys.ActorOf(Props.Create(() => new OrderValidatorActor()));\n    actor.Tell(new ValidateOrder(orderId: 123, items: _testItems));\n\n    // Sometimes this times out\n    var result = ExpectMsg<OrderValidated>(TimeSpan.FromSeconds(5));\n    Assert.Equal(123, result.OrderId);\n    Assert.True(result.IsValid);\n\n    actor.Tell(new ValidateOrder(orderId: 456, items: _emptyItems));\n    var result2 = ExpectMsg<OrderRejected>(TimeSpan.FromSeconds(5));\n    Assert.Equal(456, result2.OrderId);\n}\n```\n\nThe actor does some async database validation inside `ReceiveAsync`. Any patterns for making actor tests less flaky?", "expected_skills": ["akka-net-testing-patterns"], "acceptable_skills": [], "should_activate": true, "category": "testing-flaky"}
{"id": "act-009", "user_prompt": "Our production setup uses cluster sharding for our TenantActor. I want to write integration tests that exercise the sharding logic -- message routing, entity passivation, the whole thing -- but I don't want to start an actual multi-node cluster in my test suite. Is there a way to run sharding in a single-node test setup?\n\n```csharp\n// Production setup\nservices.AddAkka(\"MySystem\", (builder, sp) =>\n{\n    builder.WithShardRegion<TenantActor>(\n        \"tenant\",\n        (system, registry, resolver) =>\n            s => Props.Create(() => new TenantActor(s)),\n        new TenantMessageExtractor(),\n        new ShardOptions { Role = \"tenant-host\" });\n});\n\npublic class TenantActor : ReceiveActor\n{\n    private readonly string _tenantId;\n\n    public TenantActor(string tenantId)\n    {\n        _tenantId = tenantId;\n        Receive<GetTenantInfo>(_ => Sender.Tell(new TenantInfo(_tenantId)));\n    }\n}\n```\n\nI need to verify messages get routed to the right entity actor in tests.", "expected_skills": ["akka-net-testing-patterns"], "acceptable_skills": ["akka-hosting-actor-patterns"], "should_activate": true, "category": "testing-sharding"}
{"id": "act-010", "user_prompt": "I'm trying to write a test for an actor that takes `IOrderRepository` and `INotificationService` through DI. In production it works fine with Akka.Hosting, but in tests I can't figure out how to provide mock versions. My test base class extends some TestKit but I don't see where to register services.\n\n```csharp\npublic class OrderFulfillmentActor : ReceiveActor\n{\n    public OrderFulfillmentActor(\n        IOrderRepository orderRepo,\n        INotificationService notifier)\n    {\n        ReceiveAsync<FulfillOrder>(async msg =>\n        {\n            var order = await orderRepo.GetByIdAsync(msg.OrderId);\n            order.MarkFulfilled();\n            await orderRepo.SaveAsync(order);\n            await notifier.SendAsync(order.CustomerId, \"Your order shipped!\");\n            Sender.Tell(new OrderFulfilled(msg.OrderId));\n        });\n    }\n}\n\n// My broken test:\npublic class OrderFulfillmentTests : TestKit\n{\n    [Fact]\n    public void Should_fulfill_order()\n    {\n        // How do I get my mocks into the actor??\n        var mockRepo = new Mock<IOrderRepository>();\n        var mockNotifier = new Mock<INotificationService>();\n        // Props.Create(() => new OrderFulfillmentActor(mockRepo.Object, mockNotifier.Object))\n        // But I read closures are bad...\n    }\n}\n```", "expected_skills": ["akka-net-testing-patterns"], "acceptable_skills": ["akka-net-best-practices"], "should_activate": true, "category": "testing-di"}
{"id": "act-011", "user_prompt": "I'm building a system where each user account gets its own actor instance. In production we'll have thousands of these across a cluster, but for development I want to run them all locally without cluster sharding overhead. Is there a pattern that lets me use the same actor code in both setups?\n\n```csharp\npublic class UserAccountActor : ReceiveActor\n{\n    private readonly string _userId;\n    private AccountState _state;\n\n    public UserAccountActor(string userId)\n    {\n        _userId = userId;\n        _state = new AccountState();\n\n        Receive<GetBalance>(msg => Sender.Tell(new BalanceResult(_state.Balance)));\n        Receive<Deposit>(msg =>\n        {\n            _state.Balance += msg.Amount;\n            Sender.Tell(new DepositConfirmed(_state.Balance));\n        });\n        Receive<Withdraw>(msg =>\n        {\n            if (_state.Balance >= msg.Amount)\n            {\n                _state.Balance -= msg.Amount;\n                Sender.Tell(new WithdrawalConfirmed(_state.Balance));\n            }\n            else\n                Sender.Tell(new InsufficientFunds(_state.Balance));\n        });\n    }\n}\n```\n\nRight now I have completely separate code paths for dev vs prod and it's a maintenance headache. Need one pattern that works in both.", "expected_skills": ["akka-hosting-actor-patterns"], "acceptable_skills": ["akka-net-best-practices"], "should_activate": true, "category": "hosting-entity-actors"}
{"id": "act-012", "user_prompt": "Our ASP.NET controllers need to send commands to actors. Right now we're using `ActorSelection` with hardcoded paths and it's brittle -- if we refactor the actor hierarchy the paths break silently. There has to be a better way to look up actors from ASP.NET.\n\n```csharp\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase\n{\n    private readonly ActorSystem _system;\n\n    public OrdersController(ActorSystem system)\n    {\n        _system = system;\n    }\n\n    [HttpPost]\n    public async Task<IActionResult> PlaceOrder([FromBody] PlaceOrderRequest req)\n    {\n        // This is awful -- hardcoded path, no compile-time safety\n        var orderActor = _system.ActorSelection(\"/user/orders/processor\");\n        var result = await orderActor.Ask<OrderPlaced>(\n            new PlaceOrder(req.CustomerId, req.Items),\n            TimeSpan.FromSeconds(5));\n        return Ok(result);\n    }\n}\n```\n\nSome of our actors have been moved and the paths are wrong but nothing warns us. Is there a typed lookup approach?", "expected_skills": ["akka-hosting-actor-patterns"], "acceptable_skills": [], "should_activate": true, "category": "hosting-required-actor"}
{"id": "act-013", "user_prompt": "I'm setting up sharding for our device actors (IoT platform, one actor per physical device). I need to write the message routing logic that extracts the device ID from incoming messages so sharding knows which shard and entity to deliver to. Not sure about the best way to structure this.\n\n```csharp\n// Messages\npublic record DeviceTelemetry(string DeviceId, double Temperature, double Humidity);\npublic record DeviceCommand(string DeviceId, string CommandType, string Payload);\npublic record GetDeviceState(string DeviceId);\n\n// Actor\npublic class DeviceActor : ReceiveActor\n{\n    public DeviceActor(string deviceId)\n    {\n        Receive<DeviceTelemetry>(msg => { /* store reading */ });\n        Receive<DeviceCommand>(msg => { /* forward to device */ });\n        Receive<GetDeviceState>(_ => Sender.Tell(_currentState));\n    }\n}\n```\n\nHow do I set up the entity ID extraction and shard allocation for these messages? We could have 50k+ devices.", "expected_skills": ["akka-hosting-actor-patterns"], "acceptable_skills": [], "should_activate": true, "category": "hosting-message-extractor"}
{"id": "act-014", "user_prompt": "I need an actor that sends digest emails to users every day at 8am. Also need to send payment reminders 3 days before due dates. I've been using `Context.System.Scheduler.ScheduleTellRepeatedly` but it doesn't survive actor restarts or app deployments -- if the service restarts at 7:55am, the 8am schedule is gone.\n\n```csharp\npublic class DigestActor : ReceiveActor\n{\n    protected override void PreStart()\n    {\n        // This is lost on restart\n        Context.System.Scheduler.ScheduleTellRepeatedly(\n            TimeSpan.Zero,\n            TimeSpan.FromHours(24),\n            Self,\n            new SendDailyDigest(),\n            Nobody.Instance);\n    }\n\n    public DigestActor(IEmailService emailService)\n    {\n        ReceiveAsync<SendDailyDigest>(async _ =>\n        {\n            var users = await _repo.GetDigestSubscribers();\n            foreach (var user in users)\n                await emailService.SendDigestAsync(user);\n        });\n    }\n}\n```\n\nIs there a durable scheduling mechanism for Akka.NET that persists across restarts?", "expected_skills": ["akka-hosting-actor-patterns"], "acceptable_skills": [], "should_activate": true, "category": "hosting-reminders"}
{"id": "act-015", "user_prompt": "We use cluster sharding in production for our entity actors but it's overkill for local dev and makes debugging painful -- the shard coordinator adds a bunch of noise to the logs and passivation timers make actors disappear while I'm stepping through code. I want a simpler local mode that still creates one actor per entity but without the cluster machinery.\n\n```csharp\n// Current production setup\nbuilder.WithShardRegion<SessionActor>(\n    \"session\",\n    (system, registry, resolver) =>\n        s => Props.Create(() => new SessionActor(s)),\n    new SessionMessageExtractor(),\n    new ShardOptions\n    {\n        Role = \"session-host\",\n        PassivateIdleEntityAfter = TimeSpan.FromMinutes(10)\n    });\n```\n\nI still need the same message routing to work (entity ID extraction from messages) but without sharding. Is there a local-only alternative that mirrors the sharding API?", "expected_skills": ["akka-hosting-actor-patterns"], "acceptable_skills": [], "should_activate": true, "category": "hosting-local-entity"}
{"id": "act-016", "user_prompt": "We just moved our Akka.NET cluster from VMs to Kubernetes and now the nodes can't find each other. We were using hardcoded seed nodes before which obviously doesn't work when pod IPs are dynamic. The cluster just never forms -- each node sits there waiting alone.\n\n```csharp\nservices.AddAkka(\"MySystem\", builder =>\n{\n    builder.WithClustering(new ClusterOptions\n    {\n        // These were our VM IPs -- useless in k8s\n        SeedNodes = new[]\n        {\n            \"akka.tcp://MySystem@10.0.1.10:4053\",\n            \"akka.tcp://MySystem@10.0.1.11:4053\"\n        },\n        Roles = new[] { \"api\" }\n    });\n});\n```\n\nWe're running as a StatefulSet with a headless service. How do we make the nodes discover each other automatically using the Kubernetes API?", "expected_skills": ["akka-net-management"], "acceptable_skills": [], "should_activate": true, "category": "management-k8s-discovery"}
{"id": "act-017", "user_prompt": "Our ops team is asking me for health check endpoints they can wire into the Kubernetes readiness and liveness probes. They need an HTTP endpoint that returns healthy/unhealthy based on whether the node has joined the cluster and is reachable. Right now we have nothing -- just the default kestrel health check that says \"Healthy\" even when the actor system is completely broken.\n\n```csharp\n// This is what we have -- it knows nothing about Akka\napp.MapHealthChecks(\"/healthz\");\n\n// What ops wants:\n// GET /healthz/ready -> 200 if node is Up in cluster, 503 otherwise\n// GET /healthz/alive -> 200 if actor system is running, 503 if dead\n```\n\nIs there an Akka-aware health check system I can plug in? We need it to reflect actual cluster membership status.", "expected_skills": ["akka-net-management"], "acceptable_skills": [], "should_activate": true, "category": "management-health-checks"}
{"id": "act-018", "user_prompt": "We're running on Azure (AKS) and I need our Akka.NET cluster nodes to discover each other without hardcoded addresses. A colleague mentioned we could use Azure Table Storage as a coordination mechanism where nodes register themselves and discover peers. How do I set this up?\n\n```csharp\nservices.AddAkka(\"OrderSystem\", builder =>\n{\n    builder.WithClustering(new ClusterOptions\n    {\n        Roles = new[] { \"order-processor\" }\n    });\n\n    // TODO: add Azure-based discovery\n    // We have a storage account: ordersakka.table.core.windows.net\n    // Connection string is in config as \"AzureStorageConnection\"\n});\n```\n\nI want each node to register on startup and find existing cluster members from the table. What NuGet packages and configuration do I need?", "expected_skills": ["akka-net-management"], "acceptable_skills": [], "should_activate": true, "category": "management-azure-discovery"}
{"id": "act-019", "user_prompt": "Our cluster formation process is completely manual and fragile. We have a wiki page that says \"start node A first, wait for it to be Up, then start nodes B and C\" and if someone starts them in the wrong order the cluster gets into a bad state. I need this to be automatic -- nodes should start in any order and the cluster should form itself.\n\n```csharp\n// Current brittle setup -- first node must have this exact address\nbuilder.WithClustering(new ClusterOptions\n{\n    SeedNodes = new[]\n    {\n        \"akka.tcp://Inventory@node-a.internal:4053\"\n    },\n    Roles = new[] { \"inventory\" }\n});\n```\n\nWe already have service discovery working for other parts of our infrastructure (Consul). Can the cluster bootstrap itself using a discovery mechanism rather than seed nodes?", "expected_skills": ["akka-net-management"], "acceptable_skills": [], "should_activate": true, "category": "management-bootstrap"}
{"id": "act-020", "user_prompt": "I'm setting up a new project with .NET Aspire and I want to add Akka.NET actors. I've got Aspire orchestrating my API project and a Postgres database already, but I'm not sure how to wire in the actor system so it plays nice with Aspire's lifecycle and configuration. Right now the actors are set up separately and don't participate in Aspire's service model at all.\n\n```csharp\n// AppHost/Program.cs\nvar builder = DistributedApplication.CreateBuilder(args);\n\nvar postgres = builder.AddPostgres(\"db\")\n    .AddDatabase(\"orders\");\n\nvar api = builder.AddProject<Projects.OrderApi>(\"orderapi\")\n    .WithReference(postgres);\n\nbuilder.Build().Run();\n\n// OrderApi/Program.cs\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddAkka(\"OrderSystem\", akkaBuilder =>\n{\n    // This works but doesn't use Aspire's connection strings\n    // or participate in the dashboard\n    akkaBuilder.WithClustering();\n});\n```\n\nHow do I properly integrate Akka.NET with Aspire so the actor system uses Aspire-managed resources?", "expected_skills": ["akka-net-aspire-configuration"], "acceptable_skills": ["akka-net-management"], "should_activate": true, "category": "aspire-setup"}
{"id": "act-021", "user_prompt": "I've got Akka.NET persistence set up with SQL Server and now I need it to work within our Aspire environment. The SQL Server instance is managed by Aspire but I can't figure out how to get the Aspire-provided connection string into the Akka persistence config. Right now I've hardcoded it and it breaks every time Aspire assigns a different port.\n\n```csharp\n// AppHost\nvar sql = builder.AddSqlServer(\"sql\")\n    .AddDatabase(\"akkajournal\");\n\nvar workerService = builder.AddProject<Projects.WorkerService>(\"worker\")\n    .WithReference(sql);\n\n// WorkerService/Program.cs\nbuilder.Services.AddAkka(\"Workers\", akkaBuilder =>\n{\n    akkaBuilder.WithSqlServerPersistence(\n        // This connection string is wrong half the time\n        \"Server=localhost,1433;Database=akkajournal;User=sa;Password=...\");\n});\n```\n\nHow do I pipe the Aspire connection string reference into Akka's persistence configuration?", "expected_skills": ["akka-net-aspire-configuration"], "acceptable_skills": [], "should_activate": true, "category": "aspire-persistence"}
{"id": "act-022", "user_prompt": "I want to test multi-node cluster scenarios locally using Aspire. Ideally I'd spin up 3 replicas of my actor service and verify they form a cluster automatically and that sharded actors distribute correctly. Right now I can only test with a single instance which doesn't catch the cluster-related bugs we keep hitting in staging.\n\n```csharp\n// AppHost -- only runs one instance\nvar actorService = builder.AddProject<Projects.ActorService>(\"actor-service\");\n\n// I want something like:\n// var actorService = builder.AddProject<Projects.ActorService>(\"actor-service\")\n//     .WithReplicas(3);  // does this even work with Akka clustering?\n```\n\nHow do I configure Aspire to run multiple replicas and have them discover each other to form an Akka cluster? Do I need special discovery configuration?", "expected_skills": ["akka-net-aspire-configuration"], "acceptable_skills": ["akka-net-management"], "should_activate": true, "category": "aspire-multi-replica"}
{"id": "act-023", "user_prompt": "I'm trying to get Akka.Management and cluster bootstrap working inside an Aspire-hosted application. In production we use Kubernetes discovery but for local Aspire development I need the management endpoints and cluster bootstrap to work with Aspire's service discovery instead. The nodes start but never find each other.\n\n```csharp\n// AppHost\nvar actorNode = builder.AddProject<Projects.ActorNode>(\"actor-node\")\n    .WithReplicas(3);\n\n// ActorNode/Program.cs\nbuilder.Services.AddAkka(\"ClusterSystem\", akkaBuilder =>\n{\n    akkaBuilder\n        .WithClustering()\n        .WithAkkaManagement()  // management port config?\n        .WithClusterBootstrap();  // how does this find other Aspire instances?\n});\n```\n\nThe management endpoints start but cluster bootstrap can't locate the other replicas. How do I connect Aspire's service discovery with Akka's cluster bootstrap?", "expected_skills": ["akka-net-aspire-configuration"], "acceptable_skills": ["akka-net-management"], "should_activate": true, "category": "aspire-cluster-management"}
{"id": "act-024", "user_prompt": "I have a page that loads a list of orders and for each order it shows the customer name and their last 5 purchases. The page takes 12 seconds to load when there are 50 orders. I'm pretty sure it's doing a query per order. How do I fix this N+1 problem?\n\n```csharp\n[HttpGet]\npublic async Task<IActionResult> GetRecentOrders()\n{\n    var orders = await _context.Orders\n        .OrderByDescending(o => o.CreatedAt)\n        .Take(50)\n        .ToListAsync();\n\n    var result = new List<OrderViewModel>();\n    foreach (var order in orders)\n    {\n        var customer = await _context.Customers\n            .FirstAsync(c => c.Id == order.CustomerId);\n        var recentPurchases = await _context.Purchases\n            .Where(p => p.CustomerId == customer.Id)\n            .OrderByDescending(p => p.Date)\n            .Take(5)\n            .ToListAsync();\n\n        result.Add(new OrderViewModel\n        {\n            OrderId = order.Id,\n            CustomerName = customer.Name,\n            RecentPurchases = recentPurchases.Select(p => p.Summary).ToList()\n        });\n    }\n\n    return Ok(result);\n}\n```\n\nI know `Include` exists but I'm not sure how to structure the query with the Take(5) on nested purchases.", "expected_skills": [], "acceptable_skills": ["efcore-patterns"], "should_activate": false, "category": "negative-efcore"}
{"id": "act-025", "user_prompt": "My Blazor Server component fetches data in `OnInitializedAsync` but the page flashes empty for a second, then shows loading, then shows data. Also if I navigate away and come back, it fetches everything again even though the data hasn't changed. I want to cache it.\n\n```csharp\n@page \"/dashboard\"\n@inject IDashboardService DashboardService\n\n<h3>Dashboard</h3>\n\n@if (_stats == null)\n{\n    <p>Loading...</p>\n}\nelse\n{\n    <StatsGrid Stats=\"_stats\" />\n    <RecentActivityList Activities=\"_activities\" />\n}\n\n@code {\n    private DashboardStats? _stats;\n    private List<Activity>? _activities;\n\n    protected override async Task OnInitializedAsync()\n    {\n        _stats = await DashboardService.GetStatsAsync();\n        _activities = await DashboardService.GetRecentActivityAsync();\n    }\n}\n```\n\nWhat's the right pattern for loading data in Blazor Server without the flash and with some caching?", "expected_skills": [], "acceptable_skills": ["modern-csharp-coding-standards"], "should_activate": false, "category": "negative-blazor"}
{"id": "act-026", "user_prompt": "My custom authentication middleware runs but the `[Authorize]` attribute on my controllers doesn't seem to use it. I think the middleware ordering is wrong. Requests to protected endpoints return 200 instead of 401.\n\n```csharp\nvar app = builder.Build();\n\napp.UseHttpsRedirection();\napp.UseStaticFiles();\napp.UseRouting();\n\n// Custom middleware that validates API keys\napp.UseMiddleware<ApiKeyAuthenticationMiddleware>();\n\napp.MapControllers();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.Run();\n```\n\nI suspect `UseAuthentication` and `UseAuthorization` need to come before `MapControllers` but I'm not sure about the correct ordering of my custom middleware relative to the built-in ones.", "expected_skills": [], "acceptable_skills": ["modern-csharp-coding-standards"], "should_activate": false, "category": "negative-middleware"}
{"id": "act-027", "user_prompt": "I'm refactoring our xUnit test suite and it's a mess. We have 400+ tests in 3 files with no organization. I want to introduce test categories, shared fixtures, and maybe `IClassFixture` for the database setup that currently runs before every single test. No actors involved -- just plain service layer tests.\n\n```csharp\npublic class OrderServiceTests\n{\n    private readonly OrderService _sut;\n    private readonly TestDbContext _db;\n\n    public OrderServiceTests()\n    {\n        // This creates a new DB for every test -- takes forever\n        _db = new TestDbContext(\n            new DbContextOptionsBuilder<AppDbContext>()\n                .UseInMemoryDatabase(Guid.NewGuid().ToString())\n                .Options);\n        _db.SeedTestData();\n        _sut = new OrderService(_db, new NullLogger<OrderService>());\n    }\n\n    [Fact]\n    public async Task PlaceOrder_WithValidItems_ReturnsConfirmation() { /* ... */ }\n    [Fact]\n    public async Task PlaceOrder_WithEmptyCart_ThrowsException() { /* ... */ }\n    // ... 150 more tests like this\n}\n```\n\nWhat's the best way to structure large xUnit test suites with shared expensive setup?", "expected_skills": [], "acceptable_skills": ["modern-csharp-coding-standards"], "should_activate": false, "category": "negative-xunit"}
{"id": "act-028", "user_prompt": "I'm debugging a performance issue where a LINQ chain that transforms a large list takes way longer than expected. I think it's because some of the chain is deferred and gets re-evaluated multiple times. Can you spot the problem?\n\n```csharp\npublic IReadOnlyList<ReportRow> GenerateReport(IEnumerable<Transaction> transactions)\n{\n    var filtered = transactions\n        .Where(t => t.Date >= _startDate && t.Date <= _endDate)\n        .Where(t => t.Amount > 0);\n\n    var enriched = filtered\n        .Select(t => new ReportRow\n        {\n            Id = t.Id,\n            Category = _categoryService.Lookup(t.CategoryId),  // DB call!\n            Amount = t.Amount,\n            FormattedDate = t.Date.ToString(\"yyyy-MM-dd\")\n        });\n\n    // Log count\n    _logger.LogInformation(\"Processing {Count} transactions\", enriched.Count());\n\n    // Check if any high-value\n    if (enriched.Any(r => r.Amount > 10000))\n        _logger.LogWarning(\"High-value transactions detected\");\n\n    return enriched.OrderBy(r => r.FormattedDate).ToList();\n}\n```\n\nThe `_categoryService.Lookup` is being called way more times than there are transactions. What's going on?", "expected_skills": [], "acceptable_skills": ["modern-csharp-coding-standards"], "should_activate": false, "category": "negative-linq"}
{"id": "act-029", "user_prompt": "I maintain an internal NuGet package shared across 8 microservices. Every time I publish a new version, at least 2 teams complain about breaking changes even when I think the change is backward compatible. I need a proper versioning strategy.\n\n```xml\n<!-- Current .csproj -- version is bumped manually and inconsistently -->\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n    <PackageId>Contoso.Shared.Contracts</PackageId>\n    <Version>2.7.0</Version>\n    <Authors>Platform Team</Authors>\n  </PropertyGroup>\n</Project>\n```\n\nSometimes I bump the patch for what's actually a minor change, or minor for what's really major. Is there a good .NET-specific approach to semver with NuGet packages? Maybe some tooling that can detect breaking changes automatically?", "expected_skills": [], "acceptable_skills": ["modern-csharp-coding-standards"], "should_activate": false, "category": "negative-nuget"}
{"id": "act-030", "user_prompt": "I'm refactoring a bunch of DTOs to use C# records and I want to use pattern matching in the handlers. The switch expression below works but the compiler warns about \"not all paths return a value\" even though I have a discard. Also not sure if I'm using records correctly here.\n\n```csharp\npublic abstract record PaymentEvent;\npublic record PaymentInitiated(string PaymentId, decimal Amount) : PaymentEvent;\npublic record PaymentAuthorized(string PaymentId, string AuthCode) : PaymentEvent;\npublic record PaymentCaptured(string PaymentId, DateTime CapturedAt) : PaymentEvent;\npublic record PaymentFailed(string PaymentId, string Reason) : PaymentEvent;\n\npublic string FormatEvent(PaymentEvent evt) => evt switch\n{\n    PaymentInitiated p => $\"Payment {p.PaymentId} started for {p.Amount:C}\",\n    PaymentAuthorized p => $\"Payment {p.PaymentId} authorized: {p.AuthCode}\",\n    PaymentCaptured p => $\"Payment {p.PaymentId} captured at {p.CapturedAt:g}\",\n    _ => \"Unknown event\"\n};\n```\n\nAlso, if I add a new record type later, I want the compiler to warn me about unhandled cases. Is there a way to get exhaustive matching in C# like you can in F#?", "expected_skills": [], "acceptable_skills": ["modern-csharp-coding-standards"], "should_activate": false, "category": "negative-records"}
{"id": "act-031", "user_prompt": "I'm converting our old MVC controllers to Minimal APIs. Most of them are straightforward but I have some endpoints with complex validation, multiple query parameters, and file uploads. The lambda is getting really long and unreadable. What's the pattern for organizing complex Minimal API endpoints?\n\n```csharp\napp.MapPost(\"/api/products\", async (\n    HttpContext ctx,\n    IProductService productService,\n    IValidator<CreateProductRequest> validator) =>\n{\n    var form = await ctx.Request.ReadFormAsync();\n    var name = form[\"name\"].ToString();\n    var price = decimal.Parse(form[\"price\"]);\n    var category = form[\"category\"].ToString();\n    var image = form.Files.GetFile(\"image\");\n\n    var request = new CreateProductRequest(name, price, category);\n    var validation = await validator.ValidateAsync(request);\n    if (!validation.IsValid)\n        return Results.ValidationProblem(validation.ToDictionary());\n\n    string? imageUrl = null;\n    if (image != null)\n    {\n        using var stream = image.OpenReadStream();\n        imageUrl = await productService.UploadImageAsync(stream, image.FileName);\n    }\n\n    var product = await productService.CreateAsync(request, imageUrl);\n    return Results.Created($\"/api/products/{product.Id}\", product);\n});\n```\n\nThis is just one endpoint and it's already 20 lines. I have 40 endpoints to convert. How should I structure this?", "expected_skills": [], "acceptable_skills": ["modern-csharp-coding-standards"], "should_activate": false, "category": "negative-minimal-api"}
